# Swift Guidelines
##### Project Structure

- This guidelines prepared for synchronization of project structure at all projects.
- Project structure should be synchronized with file system.
- This project structure is created for comfortable project usage.

## Expected structure

```
Project folder
    swiftgen.yml
    Application 
    Resources
    Sources
```

**swiftgen.yml** - SwiftGen script file
**Application** - Repository for main project files like:
 - Info.plist 
 - LaunchScreen.storyboard
 - AppDelegate 
 - and all files meant to be config files
**Resources** - repository for files like:
- Localizable strings
- Images Assets
- Images Color 
- and all files meant to be resources
**Sources** - All project files and repositories
    
    
##### Application folder

This folder is used to contain all project files that can be used as base files like AppDelegate, LaunchScreen.storyboard and for configuration files like Info.plist, Firebase config files etc.

##### Resources folder

```
Resources
    Localizable
    Assets 
    Templates
    Generated
```
**Localizable** - contains all files that can be localized
**Assets** - contains separate Assets for every type of media files, like:
- **Assets.xcassets** as holder for app icon, LaunchScreen (for older versions) and global media used by project directly
- **Colors.xcassets** as holder for all colors used by app via code or Xcode UI
- **Images.xcassets** as holder for all images used by app via code or Xcode UI
- Or any other file as resource like fonts etc.

**Templates** - contains files as configuration for SwiftGen
**Generated** - contains files as generated by SwiftGen

##### Sources folder
```
Sources
    Lib
    Models
    Network
    Coordinators 
    UI
```

**Lib**
```
Lib
    Extensions
        UIKit
        Foundation
    Mixins
    Functions
    Services
    AppKit
```
**Models** - contains all globaly used models
**Network**
This folder structure meant to be comfortable to navigate, so if model used only in one request it supposed to side by side with its request, otherwise it supposed to be located in global folder for models used (created) for networking.
This approach can help to allocate all network logic to separate it into package or framework to be used as one point network service for different targets such as watch OS, tv OS or event mac OS.
```
Network
    Models
    Flow
        Model
        Request
```
**Coordinators**
This folder supposed to hold only coordinators as flow maps, so they can be located side by side in one folder.
```
Coordinators
    AppCoordinator
    FlowCoordinator
```
**UI**
UI folder supposed to hold all controllers, viewmodels, views and all needed files by flows. As file structure meant to be comfortable, so we define major flow of app and making top separation and that we can make inside separation for smaller flows inside one top flow, like:
- Auth Flow
- Onboarding Flow
- Main Flow

Where **Auth Flow** for example, contains flows by controllers:
- Sign In
- Sign Up
- Forgot Password
- etc.

And **Main Flow** for example, contains smaller flows (Tab bar controllers with its logical flow that can be deeper):
- Feed Flow
- Booking Flow
- Profile Flow
- Settings Flow
- etc.
```
UI
    Auth Flow
        SignInController
        SignUpController
        ForgotPasswordController
    Main Flow
        Feed Flow
            FeedFlow.storyboard (if we use storyboards)
            EventsController
            EventController
        Profile Flow
            ProfileFlow.storyboard (if we use storyboards)_
            ProfileController
            EditProfileController
```
So this flow mirrors flow using app for easier way for any developer to navigate using app and simultaneously navigate through file structure.

##### Controller folder
```
SomeController
    View
        SomeView.swift
    ViewModel
        SomeViewModel.swift
        SomeViewModelImpl.swift
    Models
    SomeController.swift
    SomeController.xib (if we use xibs)
```
For easier and cleaner usage we separate controller folder by file types.

**SomeView.swift** - View separated from controller to allocate UI logic and make files smaller.

**SomeViewModel.swift**
```
// MARK: - Events

enum SomeViewModelEvent {
    case onAuthorize
    case onError(Error)
    case onForget
    case onSignUp
}

// MARK: - Actions

enum SomeViewModelAction {
    case onSignUp
    case onForgetPass
}

protocol SomeViewModel: ViewModel where Input: SomeViewModelInput, Output: SomeViewModelOutput { }

protocol SomeViewModelInput {
    var email: CurrentValueSubject<String, Never> { get }
    var password: CurrentValueSubject<String, Never> { get }
    var onAction: PassthroughSubject<SomeViewModelAction, Never> { get }
}

protocol SomeViewModelOutput {
    var someValue: CurrentValueSubject<String, Never> { get }
    var eventHandler: PassthroughSubject<SomeViewModelEvent, Never> { get }
}
```

ViewModel idea meant to use only **Input** and **Output** as only two access points to viewmodel.
- **Input** is used to pass data into viewmodel for business logic to opearate with.
For example we have **onAction** PassthroughSubject with SomeViewModelAction as actions that UI performed and needs to be processed by viewModel or **email** CurrentValueSubject that passes entered data into viewmodel for further processing.
- **Output** is used as processed data to represent in UI or with 

**SomeViewModelEvent** - Event enum that needs to be handled with **eventHandler** PassthroughSubject for Coordinator to process events it is responsible to.
```
viewModel.output.eventHandler.sink { [weak self] event in
    switch event {
        case onAuthorize:
            ...
        case onError(let error):
            ...
        case onForget:
            ...
        case onSignUp:
            ...
    }
}.store(in: &localSubscribers)
```

**SomeViewModelImpl.swift**
```
inal class SomeViewModelImpl: SomeViewModel {
    
    // MARK: - Subtypes
    
    struct Input: SomeViewModelInput {
        var email: CurrentValueSubject<String, Never>
        var password: CurrentValueSubject<String, Never>
        let onAction: PassthroughSubject<SomeViewModelAction, Never>
    }
    
    struct Output: SomeViewModelOutput {
        var someValue: CurrentValueSubject<String, Never>
        var eventHandler: PassthroughSubject<SomeViewModelEvent, Never>
    }
    
    // MARK: - Public Properties
    
    let input: Input
    let output: Output
    
    // MARK: - Private Properties
    
    //  Input
    private var email = CurrentValueSubject<String, Never>("")
    private var password = CurrentValueSubject<String, Never>("")
    private let onAction = PassthroughSubject<SignInVMAction, Never>()
    
    // Output
    private var someValue = CurrentValueSubject<Int, Never>(0)
    private let eventHandler = PassthroughSubject<SignInVMEvent, Never>()
    
    private var cancellables: Set<AnyCancellable> = []
    
    // MARK: - Initializations and Deallocation
    
    deinit {
        print(self)
    }
    
    init() {
        self.input = .init(email: self.email,
                           password: self.password,
                           onAction: self.onAction)
        self.output = .init(someValue: self.someValue, 
                            eventHandler: self.eventHandler)
        self.bind()
    }
    
    // MARK: - Binding
    
    private func bind() {
        self.input.onAction
            .sink { [weak self] action in
                switch action {
                case .signIn:
                    ... some signIn logic trigger
                case .onSignUp:
                    ... some signUp logic trigger
                case .onForgetPass:
                // Sending event to coordinator to present onForget flow
                    self?.eventHandler.send(.onForget)
                }
            }
            .store(in: &cancellables)
    }
}
```

**Models folder** - meant to contain all models that used **ONLY** at this controller flow, otherwise it must be located at global models folder.

**SomeController.swift** - as lightweight version without UI and business logic separated to different files only controller know about **UI** and **viewmodel** so main task is to be responsive for UI actions, delegation etc. and bind it to input or output of viewmodel.
For example (controller know someButton that is located in rootView (SomeView created earlier) so it binds tap on that button to viewmodels input action with action type performed):
```
self.rootView?.someButton?
            .tapPublisher
            .sink { [weak self] _ in
                self?.viewModel.input.onAction.send(.someButtonTapped)
            }
            .store(in: &cancellables)
```

**SomeController.xib** - UI way to assemble view, so as way when we can see interface, it must be informative and prefilled with real data for any developer to open this xib and see potential UI and understand it. We must avoid making xib as simple skeleton without any represented data. (If we add label, it must be filled with mock data, same will be with any UI elements like buttons, ImageViews etc.)
This way makes easier to navigate and understand what file takes what responsibilities.
